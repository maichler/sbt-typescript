/*
 * Copyright 2014 Michael Aichler
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* global process, require */

(function () {

    // FIXME: find a way to include this via node dependencies
    var requireMapcat = function() {
        var exports = {};
        (function(exports) {
            // Generated by CoffeeScript 1.8.0
            var SourceMapConsumer, SourceMapGenerator, path, readFileSync, writeFileSync, _ref, _ref1;

            _ref = require('fs'), readFileSync = _ref.readFileSync, writeFileSync = _ref.writeFileSync;

            path = require('path');

            _ref1 = require('source-map'), SourceMapConsumer = _ref1.SourceMapConsumer, SourceMapGenerator = _ref1.SourceMapGenerator;

            exports.cat = function(inputMapFiles, outJSFile, outMapFile, maproot) {
                var buffer, f, generator, lineOffset, map, src, srcPath, _i, _len;
                buffer = [];
                generator = new SourceMapGenerator({
                    file: outJSFile
                });
                lineOffset = 0;
                for (_i = 0, _len = inputMapFiles.length; _i < _len; _i++) {
                    f = inputMapFiles[_i];
                    map = new SourceMapConsumer(readFileSync(f, 'utf-8'));
                    srcPath = path.join(path.dirname(f), map.file);
                    src = readFileSync(srcPath, 'utf-8');
                    src = src.replace(/\/\/[@#]\ssourceMappingURL[^\r\n]*/g, '//');
                    buffer.push(src);
                    map.eachMapping(function(mapping) {
                        var origSrc;
                        origSrc = path.join(path.dirname(f), mapping.source);
                        mapping = {
                            generated: {
                                line: mapping.generatedLine + lineOffset,
                                column: mapping.generatedColumn
                            },
                            original: {
                                line: mapping.originalLine,
                                column: mapping.originalColumn
                            },
                            source: path.relative(path.dirname(outMapFile), origSrc)
                        };
                        return generator.addMapping(mapping);
                    });
                    lineOffset += src.split('\n').length;
                }
                if (maproot === null) {
                    buffer.push("//# sourceMappingURL=" + (path.relative(path.dirname(outJSFile), outMapFile)));
                } else {
                    buffer.push("//# sourceMappingURL=" + (maproot + path.relative(path.dirname(outJSFile), outMapFile)));
                }
                writeFileSync(outJSFile, buffer.join('\n'), 'utf-8');
                return writeFileSync(outMapFile, generator.toString(), 'utf-8');
            };
        })(exports);
        return exports;
    };

    // FIXME: find a way to include this via node dependencies
    var requireDepGraph = function() {
        var exports = {};
        (function(exports){
            /**
             * A simple dependency graph
             */

            /**
             * Helper for creating a Depth-First-Search on
             * a set of edges.
             *
             * Detects cycles and throws an Error if one is detected.
             *
             * @param edges The set of edges to DFS through
             * @param leavesOnly Whether to only return "leaf" nodes (ones who have no edges)
             * @param result An array in which the results will be populated
             */
            function createDFS(edges, leavesOnly, result) {
                var currentPath = [];
                var visited = {};
                return function DFS(name) {
                    visited[name] = true;
                    currentPath.push(name);
                    edges[name].forEach(function (edgeName) {
                        if (!visited[edgeName]) {
                            DFS(edgeName);
                        } else if (currentPath.indexOf(edgeName) >= 0) {
                            currentPath.push(edgeName);
                            throw new Error('Dependency Cycle Found: ' + currentPath.join(' -> '));
                        }
                    });
                    currentPath.pop();
                    if ((!leavesOnly || edges[name].length === 0) && result.indexOf(name) === -1) {
                        result.push(name);
                    }
                };
            }

            /**
             * Simple Dependency Graph
             */
            var DepGraph = exports.DepGraph = function DepGraph() {
                this.nodes = {};
                this.outgoingEdges = {}; // Node name -> [Dependency Node name]
                this.incomingEdges = {}; // Node name -> [Dependant Node name]
            };
            DepGraph.prototype = {
                /**
                 * Add a node to the dependency graph. If a node with the specified
                 * name already exists, this method will do nothing.
                 */
                addNode:function (name) {
                    if (!this.hasNode(name)) {
                        this.nodes[name] = name;
                        this.outgoingEdges[name] = [];
                        this.incomingEdges[name] = [];
                    }
                },
                /**
                 * Remove a node from the dependency graph. If a node with the specified
                 * name does not exist, this method will do nothing.
                 */
                removeNode:function (name) {
                    if (this.hasNode(name)) {
                        delete this.nodes[name];
                        delete this.outgoingEdges[name];
                        delete this.incomingEdges[name];
                        [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {
                            Object.keys(edgeList).forEach(function (key) {
                                var idx = edgeList[key].indexOf(name);
                                if (idx >= 0) {
                                    edgeList[key].splice(idx, 1);
                                }
                            }, this);
                        });
                    }
                },
                /**
                 * Check if a node exists in the graph
                 */
                hasNode:function (name) {
                    return !!this.nodes[name];
                },
                /**
                 * Add a dependency between two nodes. If either of the nodes does not exist,
                 * an Error will be thrown.
                 */
                addDependency:function (from, to) {
                    if (!this.hasNode(from)) {
                        throw new Error('Node does not exist: ' + from);
                    }
                    if (!this.hasNode(to)) {
                        throw new Error('Node does not exist: ' + to);
                    }
                    if (this.outgoingEdges[from].indexOf(to) === -1) {
                        this.outgoingEdges[from].push(to);
                    }
                    if (this.incomingEdges[to].indexOf(from) === -1) {
                        this.incomingEdges[to].push(from);
                    }
                    return true;
                },
                /**
                 * Remove a dependency between two nodes.
                 */
                removeDependency:function (from, to) {
                    var idx;
                    if (this.hasNode(from)) {
                        idx = this.outgoingEdges[from].indexOf(to);
                        if (idx >= 0) {
                            this.outgoingEdges[from].splice(idx, 1);
                        }
                    }

                    if (this.hasNode(to)) {
                        idx = this.incomingEdges[to].indexOf(from);
                        if (idx >= 0) {
                            this.incomingEdges[to].splice(idx, 1);
                        }
                    }
                },
                /**
                 * Get an array containing the nodes that the specified node depends on (transitively).
                 *
                 * Throws an Error if the graph has a cycle, or the specified node does not exist.
                 *
                 * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
                 * in the array.
                 */
                dependenciesOf:function (name, leavesOnly) {
                    if (this.hasNode(name)) {
                        var result = [];
                        var DFS = createDFS(this.outgoingEdges, leavesOnly, result);
                        DFS(name);
                        var idx = result.indexOf(name);
                        if (idx >= 0) {
                            result.splice(idx, 1);
                        }
                        return result;
                    }
                    else {
                        throw new Error('Node does not exist: ' + name);
                    }
                },
                /**
                 * get an array containing the nodes that depend on the specified node (transitively).
                 *
                 * Throws an Error if the graph has a cycle, or the specified node does not exist.
                 *
                 * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
                 */
                dependantsOf:function (name, leavesOnly) {
                    if (this.hasNode(name)) {
                        var result = [];
                        var DFS = createDFS(this.incomingEdges, leavesOnly, result);
                        DFS(name);
                        var idx = result.indexOf(name);
                        if (idx >= 0) {
                            result.splice(idx, 1);
                        }
                        return result;
                    } else {
                        throw new Error('Node does not exist: ' + name);
                    }
                },
                /**
                 * Construct the overall processing order for the dependency graph.
                 *
                 * Throws an Error if the graph has a cycle.
                 *
                 * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
                 */
                overallOrder:function (leavesOnly) {
                    var self = this;
                    var result = [];
                    var keys = Object.keys(this.nodes);
                    if (keys.length === 0) {
                        return result; // Empty graph
                    } else {
                        // Look for cycles - we run the DFS starting at all the nodes in case there
                        // are several disconnected subgraphs inside this dependency graph.
                        var CycleDFS = createDFS(this.outgoingEdges, false, []);
                        keys.forEach(function(n) {
                            CycleDFS(n);
                        });

                        var DFS = createDFS(this.outgoingEdges, leavesOnly, result);
                        // Find all potential starting points (nodes with nothing depending on them) an
                        // run a DFS starting at these points to get the order
                        keys.filter(function (node) {
                            return self.incomingEdges[node].length === 0;
                        }).forEach(function (n) {
                            DFS(n);
                        });

                        return result;
                    }
                },


            };
        })(exports);
        return exports;
    };

    "use strict";

    var fs = require('fs');
    var jst = require("jstranspiler");
    var mkdirp = require("mkdirp");
    var path = require("path");

    var DepGraph = requireDepGraph().DepGraph;
    var mapcat = requireMapcat();

    var args = jst.args(process.argv);
    var logger = makeLogger(args.options.logLevel);
    console.log("\u0010" + JSON.stringify(run(args)));

    /**
     * Reads and returns the list of referenced files from a dependency file.
     *
     * The dependency file is expected to have a file extension of '.deps' and
     * to reside next to the source file.
     *
     * @param {string} sourceFile
     * @returns {Array<{source:string,target:string}>}
     */
    function readReferencedFiles(sourceFile) {

        var depFile = sourceFile + ".deps";
        if (!fs.existsSync(depFile)) {
            throw Error("Dependency file not found: " + depFile);
        }

        var result = JSON.parse(fs.readFileSync(depFile, "utf-8"));
        if (1 !== result.version) {
            throw Error("Invalid dependency version <"+result.version+"> in " + depFile);
        }

        var referencedFiles = result.referencedFiles;
        if (!referencedFiles) {
            var msg = "Dependency file does not define property <referencedFiles>: " + depFile;
            throw Error(msg);
        }

        if (referencedFiles instanceof Array) {
            return referencedFiles;
        }

        var msg = "Expected <referencedFiles> to be an instance of Array: " + depFile;
        throw Error(msg);
    }

    /**
     * Combines a list of source files into an output file.
     *
     * @param {string} outputFile
     * @param {Array<string>} sourceFiles
     */
    function combine(outputFile, sourceFiles) {

        var outputDir = path.dirname(outputFile);
        if (!fs.existsSync(outputDir)) {
            mkdirp.sync(path.dirname(outputFile));
        }

        var stream = fs.createWriteStream(outputFile);
        sourceFiles.forEach(function(sourceFile){
            try {
                var content = fs.readFileSync(sourceFile, "utf-8");
                stream.write(content);
                stream.write('\n');
            } catch(error) {
                stream.end();
                throw error;
            }
        });
        stream.end();
    }

    /**
     * Combines the list of source files and corresponding source maps into
     * a single output file and source map, respectively.
     *
     * @param {string} outputFile
     * @param {Array<string>} sourceFiles
     */
    function combineWithMap(outputFile, sourceFiles) {

        var outputDir = path.dirname(outputFile);
        if (!fs.existsSync(outputDir)) {
            mkdirp.sync(path.dirname(outputFile));
        }

        var sourceMapFiles = [];
        sourceFiles.forEach(function(sourceFile) {
            sourceMapFiles.push(sourceFile + ".map");
        });

        mapcat.cat(sourceMapFiles, outputFile, outputFile + ".map", null);
    }

    /**
     * Copies a single source file and returns a new mapping.
     *
     * @param {string} basePath
     * @param {{source:string,target:string}} sourceFile
     */
    function copyAndMapSourceFile(basePath, sourceFile) {

        var targetFile = path.join(basePath, sourceFile.target);
        var targetDir = path.dirname(targetFile);

        mkdirp.sync(targetDir);
        fs.writeFileSync(targetFile, fs.readFileSync(sourceFile.source));

        return {source:targetFile, target:sourceFile.target};
    }

    /**
     * Copies all files from {@code sourceFileMappings} to {@code basePath}
     * and returns a mapping which reflects the new source file locations.
     *
     * @param {string} basePath
     * @param {Array<{source:string,target:string}>} sourceFileMappings
     */
    function copyAndMapSourceFiles(basePath, sourceFileMappings) {
        return sourceFileMappings.map(function(sourceFile){
            return copyAndMapSourceFile(basePath, sourceFile);
        });
    }

    /**
     *
     * @param basePath
     * @param {Array<{source:string,target:string}>} sourceFiles
     * @returns {*}
     *
     * @see readReferencedFiles()
     */
    function buildDependencyGraph(basePath, sourceFiles) {
        var graph = new DepGraph();
        sourceFiles.forEach(function(sourceFile){
            graph.addNode(sourceFile);
            var referencedFiles = readReferencedFiles(sourceFile);
            referencedFiles.forEach(function(mapping){

                var reference = path.join(basePath, mapping.target);

                if (!graph.hasNode(reference)) {
                    graph.addNode(reference);
                }
                graph.addDependency(sourceFile, reference);
            });
        });
        return graph.overallOrder();
    }

    /**
     * Maps {@code sourceFile} to its property {@code source}.
     *
     * @param {{source:string,target:string}} sourceFile
     * @returns {string}
     */
    function toSource(sourceFile) {
        return sourceFile.source;
    }

    /**
     * Filter which includes files with the given extensions.
     *
     * @param {Array<string>} extensions
     * @returns {Function}
     */
    function includeExts(extensions) {
        return function(sourceFile) {
            var ext = path.extname(sourceFile.target);
            return (extensions.indexOf(ext) === 0);
        }
    }

    /**
     * Filter which excludes files with the given extensions.
     *
     * @param {Array<string>} extensions
     * @returns {Function}
     */
    function excludeExts(extensions) {
        return function(sourceFile) {
            var ext = path.extname(sourceFile.target);
            return (extensions.indexOf(ext) === -1);
        }
    }

    /**
     * Main entry point.
     *
     * @param {{sourceFileMappings:Array,options:{bundlePath:string},target:string}} args
     * @returns {Array<string>}
     */
    function run(args) {

        logger.debug("Got arguments", args);

        var moduleKind = args.options.moduleKind;
        if (['','system'].indexOf(moduleKind) === -1) {
            var msg = "Module type <" + moduleKind + " is not supported right now.";
            throw Error(msg);
        }

        var dependencies = args.options.dependencies;
        if (true !== dependencies) {
            msg = "TypescriptKeys.dependencies must be enabled for bundling to work.";
            throw Error(msg);
        }

        var outputFile = path.join(args.target, args.options.bundlePath);
        var sourceFileMappings = copyAndMapSourceFiles(args.target, args.sourceFileMappings);
        var javascriptSources  = sourceFileMappings.filter(includeExts(['.js','.jsx'])).map(toSource);

        var sourceFiles = buildDependencyGraph(args.target, javascriptSources);

        logger.debug("Source files ordered", sourceFiles);

        if (!args.options.sourceMap) {
            combine(outputFile, sourceFiles);
        } else {
            combineWithMap(outputFile, sourceFiles);
        }

        var output = sourceFileMappings
            .filter(excludeExts(['.js', '.jsx', '.deps', '.map']))
            .map(toSource);

        output.push(outputFile);
        if (args.options.sourceMap) {
            output.push(outputFile + ".map");
        }

        logger.debug("Result ", output);
        return output;
    }

    function makeLogger(level) {
        return {
            debug: function(message) {
                if ('debug' === level) {
                    console.log.apply(this, arguments);
                }
            },
            info: function(message) {
                if ('debug' === level || 'info' === level) {
                    console.log.apply(this, arguments);
                }
            },
            error: function(message) {
                if ('debug' === level || 'info' === level || 'error' === level) {
                    console.error.apply(this, arguments);
                }
            }
        }
    }
})();
